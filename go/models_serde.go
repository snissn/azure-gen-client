//go:build go1.18
// +build go1.18

// Code generated by Microsoft (R) AutoRest Code Generator (autorest: 3.9.2, generator: @autorest/go@4.0.0-preview.44)
// Changes may cause incorrect behavior and will be lost if the code is regenerated.
// DO NOT EDIT.

package 

import (
	"encoding/json"
	"fmt"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"reflect"
)

// MarshalJSON implements the json.Marshaller interface for type APIResponse.
func (a APIResponse) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "code", a.Code)
	populate(objectMap, "message", a.Message)
	populate(objectMap, "type", a.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type APIResponse.
func (a *APIResponse) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "code":
				err = unpopulate(val, "Code", &a.Code)
				delete(rawMsg, key)
		case "message":
				err = unpopulate(val, "Message", &a.Message)
				delete(rawMsg, key)
		case "type":
				err = unpopulate(val, "Type", &a.Type)
				delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type Category.
func (c Category) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", c.ID)
	populate(objectMap, "name", c.Name)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Category.
func (c *Category) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
				err = unpopulate(val, "ID", &c.ID)
				delete(rawMsg, key)
		case "name":
				err = unpopulate(val, "Name", &c.Name)
				delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type Order.
func (o Order) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "complete", o.Complete)
	populate(objectMap, "id", o.ID)
	populate(objectMap, "petId", o.PetID)
	populate(objectMap, "quantity", o.Quantity)
	populateTimeRFC3339(objectMap, "shipDate", o.ShipDate)
	populate(objectMap, "status", o.Status)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Order.
func (o *Order) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "complete":
				err = unpopulate(val, "Complete", &o.Complete)
				delete(rawMsg, key)
		case "id":
				err = unpopulate(val, "ID", &o.ID)
				delete(rawMsg, key)
		case "petId":
				err = unpopulate(val, "PetID", &o.PetID)
				delete(rawMsg, key)
		case "quantity":
				err = unpopulate(val, "Quantity", &o.Quantity)
				delete(rawMsg, key)
		case "shipDate":
				err = unpopulateTimeRFC3339(val, "ShipDate", &o.ShipDate)
				delete(rawMsg, key)
		case "status":
				err = unpopulate(val, "Status", &o.Status)
				delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PathsN18Gb4PetPetidPostRequestbodyContentApplicationXWwwFormUrlencodedSchema.
func (p PathsN18Gb4PetPetidPostRequestbodyContentApplicationXWwwFormUrlencodedSchema) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "name", p.Name)
	populate(objectMap, "status", p.Status)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PathsN18Gb4PetPetidPostRequestbodyContentApplicationXWwwFormUrlencodedSchema.
func (p *PathsN18Gb4PetPetidPostRequestbodyContentApplicationXWwwFormUrlencodedSchema) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "name":
				err = unpopulate(val, "Name", &p.Name)
				delete(rawMsg, key)
		case "status":
				err = unpopulate(val, "Status", &p.Status)
				delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PathsQ1AtbnPetPetidUploadimagePostRequestbodyContentMultipartFormDataSchema.
func (p PathsQ1AtbnPetPetidUploadimagePostRequestbodyContentMultipartFormDataSchema) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "additionalMetadata", p.AdditionalMetadata)
	populate(objectMap, "file", p.File)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PathsQ1AtbnPetPetidUploadimagePostRequestbodyContentMultipartFormDataSchema.
func (p *PathsQ1AtbnPetPetidUploadimagePostRequestbodyContentMultipartFormDataSchema) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalMetadata":
				err = unpopulate(val, "AdditionalMetadata", &p.AdditionalMetadata)
				delete(rawMsg, key)
		case "file":
				err = unpopulate(val, "File", &p.File)
				delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type Pet.
func (p Pet) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "category", p.Category)
	populate(objectMap, "id", p.ID)
	populate(objectMap, "name", p.Name)
	populate(objectMap, "photoUrls", p.PhotoUrls)
	populate(objectMap, "status", p.Status)
	populate(objectMap, "tags", p.Tags)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Pet.
func (p *Pet) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "category":
				err = unpopulate(val, "Category", &p.Category)
				delete(rawMsg, key)
		case "id":
				err = unpopulate(val, "ID", &p.ID)
				delete(rawMsg, key)
		case "name":
				err = unpopulate(val, "Name", &p.Name)
				delete(rawMsg, key)
		case "photoUrls":
				err = unpopulate(val, "PhotoUrls", &p.PhotoUrls)
				delete(rawMsg, key)
		case "status":
				err = unpopulate(val, "Status", &p.Status)
				delete(rawMsg, key)
		case "tags":
				err = unpopulate(val, "Tags", &p.Tags)
				delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type Tag.
func (t Tag) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", t.ID)
	populate(objectMap, "name", t.Name)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Tag.
func (t *Tag) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", t, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
				err = unpopulate(val, "ID", &t.ID)
				delete(rawMsg, key)
		case "name":
				err = unpopulate(val, "Name", &t.Name)
				delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", t, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type User.
func (u User) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "email", u.Email)
	populate(objectMap, "firstName", u.FirstName)
	populate(objectMap, "id", u.ID)
	populate(objectMap, "lastName", u.LastName)
	populate(objectMap, "password", u.Password)
	populate(objectMap, "phone", u.Phone)
	populate(objectMap, "userStatus", u.UserStatus)
	populate(objectMap, "username", u.Username)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type User.
func (u *User) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", u, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "email":
				err = unpopulate(val, "Email", &u.Email)
				delete(rawMsg, key)
		case "firstName":
				err = unpopulate(val, "FirstName", &u.FirstName)
				delete(rawMsg, key)
		case "id":
				err = unpopulate(val, "ID", &u.ID)
				delete(rawMsg, key)
		case "lastName":
				err = unpopulate(val, "LastName", &u.LastName)
				delete(rawMsg, key)
		case "password":
				err = unpopulate(val, "Password", &u.Password)
				delete(rawMsg, key)
		case "phone":
				err = unpopulate(val, "Phone", &u.Phone)
				delete(rawMsg, key)
		case "userStatus":
				err = unpopulate(val, "UserStatus", &u.UserStatus)
				delete(rawMsg, key)
		case "username":
				err = unpopulate(val, "Username", &u.Username)
				delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", u, err)
		}
	}
	return nil
}

func populate(m map[string]interface{}, k string, v interface{}) {
	if v == nil {
		return
	} else if azcore.IsNullValue(v) {
		m[k] = nil
	} else if !reflect.ValueOf(v).IsNil() {
		m[k] = v
	}
}

func unpopulate(data json.RawMessage, fn string, v interface{}) error {
	if data == nil {
		return nil
	}
	if err := json.Unmarshal(data, v); err != nil {
		return fmt.Errorf("struct field %s: %v", fn, err)
	}
	return nil
}

